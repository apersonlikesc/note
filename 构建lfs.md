## Linux From Scratch 1
### 准备
准备空间大概8g 准备在u盘上构建系统
我准备将u盘对半分成两个盘
一个安装系统,就用ext4
一个当作普通的u盘来用
记得分区的时候格式化
可以使用fdisk 或者 其他工具

另外: 我的arch上没有创建swap分区

### 挂载U盘/移动硬盘
使用fdisk -l命令
得到
```
Disk /dev/sdb：29 GiB，31104958464 字节，60751872 个扇区
单元：扇区 / 1 * 512 = 512 字节
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节
磁盘标签类型：dos
磁盘标识符：0xcad4ebea

设备       启动 起点     末尾     扇区 大小 Id 类型
/dev/sdb4  *      63 60751871 60751809  29G  c W95 FAT32 (LBA)
```
创建文件夹 将sdb4挂载到文件夹上


一般u盘会自动挂载,像我的系统就是挂载到run/s/xxx 下面
不过官方建议还是挂载到 /mnt/lfs 下面

`mount -v -t ext4 /dev/<xxx> $LFS`	# 将 /dev/<xxx> 挂载到 $LFS

如果重启设备，可能进入后发现 /mnt/lfs 目录下没有内容，这是只需要再次挂载 /dev/<xxx> 到 /mnt/lfs。 此处 <xxx> 用实际的设备名称代替

这里我只使用一个 / 分区

如果 LFS 使用了多个分区，(比如：一个 /，一个 /usr)，用下面的命令挂载它们：

```
mkdir -pv $LFS	# 建立 / 分区的挂载点
mount -v -t ext4 /dev/<xxx> $LFS	# 将 /dev/<xxx> 挂载到 $LFS
mkdir -v $LFS/usr	# 建立 $LFS/usr 挂载点，用于挂载 /usr
mount -v -t ext4 /dev/<yyy> $LFS/usr	# 将 /dev/<yyy> 挂载到 $LFS/usr
```

附:
如果你正在使用交换分区，用 swapon 命令确保它已经启用。

`/sbin/swapon -v /dev/<zzz>`
用 swap 分区的名字替换<zzz>。


注意:确保你的 echo $LFS 在root与用户帐号上时/mnt/lfs 你可以使用全局变量来设置

### 软件包和补丁

`mkdir -v $LFS/sources`
在$lfs里创建sources文件夹 来存放 下载好的软件包和补丁

设置目录的写权限和粘滞模式。“粘滞模式”意思是就算有多个用户对某个目录有写权限，仍然只有该文件的主人能删除一个粘滞目录里的文件。下面的命令可以打开写权限和粘滞模式：
`chmod -v a+wt $LFS/sources`

下载软件包可以去中科院镜像里面去下载
里面已经有了md5sums 解压放到source里面就行
下载完成后使用md5sums检验====>将下载的md5sums 放到sources目录下

```
pushd $LFS/sources
md5sum -c md5sums
popd
```

### 最后的准备工作
 我们还需要为构建临时系统做一些额外的准备工作。我们会在 $LFS 中新建一个文件夹用于临时工具的安装，增加一个非特权用户用于降低风险，并为该用户创建合适的构建环境。我们也会解释用于测量构建 LFS 软件包花费时间的单位，或者称为“标准编译单位（SBU）”，并给出一些关于软件包测试套件的信息

以 root 用户运行以下的命令来创建需要的文件夹：
`mkdir -v $LFS/tools`

下一步是在宿主系统中创建 /tools 的符号链接，将其指向 LFS 分区中新建的文件夹。同样以 root 用户运行下面的命令：

`ln -sv $LFS/tools /`

#### 添加 LFS 用户

当以 root 用户登录时，犯一个小错误可能会破坏或摧毁整个系统。因此，我们建议在本章中以非特权用户编译软件包。你可以使用你自己的用户名，但要容易的话，就建立一个干净的工作环境，创建一个名为 lfs 的新用户作为新组（名字也是 lfs ）的成员，并在安装过程中使用这个用户。以 root 用户运行以下命令来添加新用户：
```
groupadd lfs
useradd -s /bin/bash -g lfs -m -k /dev/null lfs
```
```
命令行选项的意思：

-s /bin/bash
把 bash 设置为 lfs 用户的默认 shell。

-g lfs
这个选项将用户 lfs 添加到组 lfs 中。

-m
为 lfs 用户创建主目录。

-k /dev/null
这个参数通过改变输入位置为特殊的空（null）设备，以防止可能从一个模版目录中（默认是 /etc/skel）复制文件。
```

lfs
这是创建的组和用户的实际名称。

要以 lfs 用户身份登录（以 root 身份登录切换到 lfs 用户时不要求 lfs 用户设置了密码），需要给 lfs 用户一个密码：
`passwd lfs`

通过更改文件夹所有者为 lfs，为用户 lfs 赋予了访问 $LFS/tools 文件夹的所有权限：

`chown -v lfs $LFS/tools`

如果正如建议的一样创建了一个单独的工作目录，给 lfs 用户赋予这个文件夹的所有权：
`chown -v lfs $LFS/sources`

下一步，以 lfs 用户身份登录。可以能通过一个虚拟控制台、显示控制器，或者下面的切换用户命令完成：
`su - lfs`

#### 设置环境
```
cat > ~/.bash_profile << "EOF"
exec env -i HOME=$HOME TERM=$TERM PS1='\u:\w\$ ' /bin/bash
EOF
```
当以 `lfs` 用户身份登录时，初始 shell 通常是一个可登录的 shell，它先读取宿主机的 `/etc/profile `文件（很可能包括一些设置和环境变量），然后是 `.bash_profile` 文件。`.bash_profile` 文件中的` exec env -i.../bin/bash` 命令用一个除了 `HOME`、`TERM `和 `PS1` 变量，完全空环境的 shell 代替运行中的 shell。**这可以确保没有不必要的或者有潜在风险的环境变量从宿主机系统中泄露到构建环境**。这里使用的技巧是为了有一个干净环境。


新的 shell 实例是一个非登录 shell，不会读取 `/etc/profile` 或者 `.bash_profile `文件，而是读取 `.bashrc `文件。 现在创建 `.bashrc` 文件：
```
cat > ~/.bashrc << "EOF"
set +h
umask 022
LFS=/mnt/lfs
LC_ALL=POSIX
LFS_TGT=$(uname -m)-lfs-linux-gnu
PATH=/tools/bin:/bin:/usr/bin
export LFS LC_ALL LFS_TGT PATH
EOF
```

`set +h `命令关闭了 `bash `的哈希功能。 哈希通常是一个有用的功能，`bash` 用一个哈希表来记录可执行文件的完整路径，以避免搜索` PATH` 的时间和又找到一个相同的可执行文件。然而，新工具要一安装后就使用。通过关闭哈希功能，一个程序准备运行时 `shell` 总是会搜索` PATH `变量。如此，`shell` 能在新编译的工具可用时马上在文件夹 `$LFS/tools` 中找到，而不是记录相同程序在其它地方的之前版本。

设置用户文件新建掩码`（umask）`为 `022 `，确保新建的文件和目录只有它们自己的所有者可写，任何人都可读和可执行(假定` open(2)` 系统调用使用的默认模式是新文件使用 `644 `模式，文件夹使用` 755 `模式)。

`LFS` 变量应该设置为选定的挂载点。

`LC_ALL` 变量控制特定程序的本地化，使得它们的消息能遵循特定国家的惯例。设置 `LC_ALL` 为 `“POSIX”` 或 `“C”`（两者是等价的），确保 `chroot` 环境中一切如期望的那样进行。

当编译我们的交叉编译器和链接器以及交叉编译我们的临时工具链时，`LFS_TGT`变量设置了一个非默认，但兼容的机器说明。5.2,“工具链技术说明”包含更多的信息。

把 `/tools/bin` 放在标准的 `PATH` 变量前面， 第五章中安装的软件一安装完成 shell 就可使用。这和关闭哈希功能一起，降低了在第五章环境中新程序可用时宿主机器使用旧程序的风险。

生效配置文件:
`source ~/.bash_profile`


#### 关于 SBU

SBU 衡量方式如下。我们以第五章编译的第一个软件包 Binutils 所用时间作为一个标准编译单位（SBU），其它软件的生成时间都以其为标准进行比较。

例如，假如编译一个软件耗时 4.5 SBU，而编译安装初代 Binutils 用时 10 分钟的话，那么编译这个软件包大约耗时 45 分钟。当然啦，对于大多数人来说，编译 Binutils 可用不了 10 分钟那么久。

在一些情况下，使用多处理器同时编译可能失败，分析错误日志变得异常困难：因为不同处理器之间的执行路线是交错的。如果你在编译的时候遇到问题，那么请回过来使用单处理器编译，以正确地查看错误消息。


### 构建临时系统
目标是生成一个临时的系统，它包含一个已知的较好工具集，该工具集可与宿主系统分离。通过使用 `chroot`，其余各章中的命令将被包含在此环境中，以保证目标 LFS 系统能够洁净且无故障地生成。该构建过程的设计就是为了使得新读者有最少的风险，同时还能有最好的指导价值。

**最后确认一次是否正确设置了 LFS 环境变量：**
`echo $LFS`
确认输出显示的是 LFS 分区挂载点的路径，在我们的例子中也就是 /mnt/lfs。

最后，必须强调两个重要的点：

**[重要] 重要**

编译指南假定你已经正确地设置了宿主系统需求和符号链接：

`shell `使用的是 `bash`。

`sh` 是到 `bash `的符号链接。

`/usr/bin/awk` 是到 `gawk `的符号链接。

`/usr/bin/yacc` 是到` bison `的符号链接或者一个执行 `bison` 的小脚本。

**[重要] 重要**

再次强调构建过程：

把所有源文件和补丁放到 `chroot` 环境可访问的目录，例如 `/mnt/lfs/sources/`。但是千万不能把源文件放在 `/mnt/lfs/tools/` 中。

进入到源文件目录。

>对于每个软件包:
1. 用 tar 程序解压要编译的软件包。在第五章中，确保解压软件包时你使用的是 lfs 用户。
2.
3. 进入到解压后创建的目录中。
4.
5. 根据指南说明编译软件包。
6.
7. 回退到源文件目录。
8.
9. 除非特别说明，删除解压出来的目录和所有编译过程中生成的  <package\>-build 目录。

这里我在使用lfs帐号进入lfs文件夹的时候出现了权限不足,我使用了chmod加了权限

之后就是漫长的编译过程
具体按照官方资料上进行编译
注意在编译过程中必须清楚知道当前步骤 make 与 make install 防止错误

====>之后的构建过程 之后补充上

#### 资料(建议配合使用)

##### 中文资料(已过期7.7)
https://linux.cn/lfs/LFS-BOOK-7.7-systemd/index.html
##### 英文资料(目前是8.2)
http://www.linuxfromscratch.org/lfs/view/stable/index.html
