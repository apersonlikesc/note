### The Boot Loader
对于PC来说，软盘，硬盘都可以被划分为一个个大小为512字节的区域，叫做扇区。一个扇区是一次磁盘操作的最小粒度。每一次读取或者写入操作都必须是一个或多个扇区。如果一个磁盘是可以被用来启动操作系统的，就把这个磁盘的第一个扇区叫做启动扇区。这一部分介绍的boot loader程序就位于这个启动扇区之中。当BIOS找到一个可以启动的软盘或硬盘后，它就会把这 **512字节** 的启动扇区加载到内存地址`0x7c00~0x7dff`这个区域内。

对于6.828，我们将采用传统的硬盘启动机制，这就意味着我们的**boot loader程序的大小必须小于512字节**。整个boot loader是由一个汇编文件，`boot/boot.S`，以及一个C语言文件，`boot/main.c`。Boot loader必须完成两个主要的功能。

 1. **首先，boot loader要把处理器从实模式转换为32bit的保护模式，因为只有在这种模式下软件可以访问超过1MB空间的内容**。

 2. 然后，**boot loader 可以通过使用x86的特定的IO指令，直接访问IDE磁盘设备寄存器，从磁盘中读取内核**。

对于boot loader来说，有一个文件很重要，`obj/boot/boot.asm`。这个文件是我们真实运行的boot loader程序的**反汇编版本**。所以我们可以把它和它的源代码即boot.S以及main.c比较一下。

#### Exercise 3：

设置一个断点在地址`0x7c00`处，这是`boot sector`被加载的位置。然后让程序继续运行直到这个断点。跟踪/boot/boot.S文件的每一条指令，同时使用boot.S文件和系统为你反汇编出来的文件obj/boot/boot.asm。你也可以使用GDB的x/i指令来获取去任意一个机器指令的反汇编指令，把源文件boot.S文件和boot.asm文件以及在GDB反汇编出来的指令进行比较。

追踪到bootmain函数中，而且还要具体追踪到readsect()子函数里面。找出和readsect()c语言程序的每一条语句所对应的汇编指令，回到bootmain()，然后找出把内核文件从磁盘读取到内存的那个for循环所对应的汇编语句。找出当循环结束后会执行哪条语句，在那里设置断点，继续运行到断点，然后运行完所有的剩下的语句。
这道题的解答在这篇日志中：http://www.cnblogs.com/fatsheep9146/p/5115086.html

下面回答一下文中提出的四个问题：
　1. 在什么时候处理器开始运行于32bit模式？到底是什么把CPU从16位切换为32位工作模式？
　答：在boot.S文件中，计算机首先工作于实模式，此时是16bit工作模式。当运行完 " ljmp $PROT_MODE_CSEG, $protcseg " 语句后，正式进入32位工作模式。根本原因是此时CPU工作在保护模式下。

　2. boot loader中执行的最后一条语句是什么？内核被加载到内存后执行的第一条语句又是什么？
　答：boot loader执行的最后一条语句是bootmain子程序中的最后一条语句 " ((void (*)(void)) (ELFHDR->e_entry))(); "，即跳转到操作系统内核程序的起始指令处。
　　   这个第一条指令位于/kern/entry.S文件中，第一句 movw $0x1234, 0x472
　　
   3. 内核的第一条指令在哪里？
　答：上一个问题中已经回答过这个问题，第一条指令位于/kern/entry.S文件中。

　4. boot loader是如何知道它要读取多少个扇区才能把整个内核都送入内存的呢？在哪里找到这些信息？
　答：首先关于操作系统一共有多少个段，每个段又有多少个扇区的信息位于操作系统文件中的Program Header Table中。这个表中的每个表项分别对应操作系统的一个段。并且每个表项的内容包括这个段的大小，段起始地址偏移等等信息。所以如果我们能够找到这个表，那么就能够通过表项所提供的信息来确定内核占用多少个扇区。
　　　那么关于这个表存放在哪里的信息，则是存放在操作系统内核映像文件的ELF头部信息中。


逻辑地址[段选择符：段内偏移地址]
